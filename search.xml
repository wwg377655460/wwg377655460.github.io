<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flask学习与Python进阶-3-进程与线程]]></title>
    <url>%2F2018%2F04%2F02%2FFlask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6-3-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程与线程什么是进程 进程是竞争计算机资源的基本单位，对于单核CPPU，同一时间永远只能执行一个应用程序，它会在不同的应用程序进程之间切换。 什么是线程 线程是进程的一部分1个进程 =&gt; 多个线程CPU越来越强，我们需要更小的单元来管理CPU的资源。线程 =&gt; 利用CPU执行代码，不能够拥有资源，但是可以访问资源（自己所在的进程）它的切换很快进程 =&gt; 分配资源 多线程 在Python中启动多线程123456789def worker(): print("I am a thread") t = threading.current_thread() print(t.getName())print("This is a test")t = threading.current_thread()print(t.getName())new_t = threading.Thread(target=worker, name="New Thread")new_t.start() 上面代码执行的结果如下：1234This is a testMainThreadI am a threadNew Thread 多线程的编程是为了更加充分的利用CPU的性能优势 但是Python不能充分的利用CPU的性能优势 :( 原因是因为Python有一个GIL（全局解释器锁），它会让Python代码同一时刻只能在一个核上执行同一的线程，Python为什么要设计这样一个锁呢？因为Python为了让代码更加简洁，在解释器的层面加了一个锁，不需要程序员编写细粒度的锁，但是这只是在一定程度上保证了线程安全。但是在一些特殊场合，比如a+=1，在Python解释器中可能会被翻译成多段bytecode，虽然有GIL，但是这多段bytecode不能保证不能中断。 值得注意的是Python的多线程在IO密集型程序中是非常有帮助的，因为GIL只是让CPU不能在同一时间执行多个线程，但是IO密集型程序大部分时间都在对数据查询上（需要等待），这部分完全可以并发执行，这时Python的多线程就非常有作用了。 Flask中的多线程Flask如何做到多线程 开启多线程12if __name__ == '__main__': app.run(host='0.0.0.0', debug=app.config['DEBUG'], threaded=True) 但是Flask如何同时处理多个请求呢？多线程？Flask内部使用字典（Local对象 werkzeug的基础库）来储存多个线程（通过线程号）=&gt; 线程隔离12345678910111213class A: b = 1my_obj = A()def worker(): # 新线程 my_obj.b = 2new_t = threading.Thread(target=worker, name='New Thread')new_t.start()time.sleep(1)print(my_obj.b) 上述代码输出结果为2，这里是因为对象A不是线程隔离的。修改代码如下：12345678910111213my_obj = Local()my_obj.b = 1def worker(): # 新线程 my_obj.b = 2 print('in new thread b is:' + str(my_obj.b))new_t = threading.Thread(target=worker, name='New Thread')new_t.start()time.sleep(1)print('in main thread b is:' + str(my_obj.b)) 输出结果：12in new thread b is:2in main thread b is:1 这里的主线程中的b不会被其他线程修改，这是因为Local对象是线程隔离的，正如我们上面说的Local是通过线程号，使用字典来做到线程隔离的。 Local源码123456789101112131415161718192021222324252627282930313233343536class Local(object): __slots__ = ('__storage__', '__ident_func__') def __init__(self): object.__setattr__(self, '__storage__', &#123;&#125;) object.__setattr__(self, '__ident_func__', get_ident) def __iter__(self): return iter(self.__storage__.items()) def __call__(self, proxy): """Create a proxy for a name.""" return LocalProxy(self, proxy) def __release_local__(self): self.__storage__.pop(self.__ident_func__(), None) def __getattr__(self, name): try: return self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) def __setattr__(self, name, value): ident = self.__ident_func__() # 获取线程号 storage = self.__storage__ try: storage[ident][name] = value except KeyError: storage[ident] = &#123;name: value&#125; def __delattr__(self, name): try: del self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) Flask中的线程隔离栈：LocalStack12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class LocalStack(object): &gt;&gt;&gt; ls = LocalStack() &gt;&gt;&gt; ls.push(42) &gt;&gt;&gt; ls.top 42 &gt;&gt;&gt; ls.push(23) &gt;&gt;&gt; ls.top 23 &gt;&gt;&gt; ls.pop() 23 &gt;&gt;&gt; ls.top 42 .. versionadded:: 0.6.1 """ def __init__(self): self._local = Local() def __release_local__(self): self._local.__release_local__() def _get__ident_func__(self): return self._local.__ident_func__ def _set__ident_func__(self, value): object.__setattr__(self._local, '__ident_func__', value) __ident_func__ = property(_get__ident_func__, _set__ident_func__) del _get__ident_func__, _set__ident_func__ def __call__(self): def _lookup(): rv = self.top if rv is None: raise RuntimeError('object unbound') return rv return LocalProxy(_lookup) def push(self, obj): """Pushes a new item to the stack""" rv = getattr(self._local, 'stack', None) if rv is None: self._local.stack = rv = [] rv.append(obj) return rv def pop(self): """Removes the topmost item from the stack, will return the old value or `None` if the stack was already empty. """ stack = getattr(self._local, 'stack', None) if stack is None: return None elif len(stack) == 1: release_local(self._local) return stack[-1] else: return stack.pop() @property def top(self): """The topmost item on the stack. If the stack is empty, `None` is returned. """ try: return self._local.stack[-1] except (AttributeError, IndexError): return None LocalStack为我们封装了push(), pop(), top()三个函数，实现了线程隔离栈123456789101112131415161718my_statck = LocalStack()my_statck.push(1)print('in main after push, value is:' + str(my_statck.top))def worker(): # 新线程 print('in new thread before push, value is:' + str(my_statck.top)) my_statck.push(2) print('in new thread after push, value is:' + str(my_statck.top))new_t = threading.Thread(target=worker, name='New Thread')new_t.start()time.sleep(1)# 主线程print('finally, in main thread value is:' + str(my_statck.top)) 上述代码执行结果为：1234in main after push, value is:1in new thread before push, value is:Nonein new thread after push, value is:2finally, in main thread value is:1 可以看出LocalStack是线程隔离的。Flask使用LocalStack隔离的是AppContext和Request Context(Request对象包含在上下文中)，Flask需要用一个变量名指向多个线程创建的多个变量 Flask使用线程隔离的意义 Flask使用线程隔离的意义在于：使当前线程能正确引用到他自己所创建的对象，而不是引用到其他线程所创建的对象。需要注意Flask中的核心对象app只有一个，他是在入口文件中创建的，只会被创建一次，每一个进程使用的都是同一个地址，同一个app对象。所以这里app可以用来让所有请求共享同一份数据（网站访问计数），但是这是不推荐的（线程安全问题）。123456789# 以线程ID号作为key的字典 -&gt; Local -&gt; LocalStock# AppContext RequestContext -&gt; LocalStack# Flask -&gt; AppContext Request -&gt; RequestContext# current_app -&gt; (LocalStack.top = AppContext top.app = Flask 只有一个)# request -&gt; (LocalStack.top = RequestContext top.request = Request 多个)]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask学习与Python进阶-2-With语句详解]]></title>
    <url>%2F2018%2F04%2F02%2FFlask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6-2-With%E8%AF%AD%E5%8F%A5%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Python中With的用法 在编写Python代码，需要链接数据库或打开文件时，我经常会使用with123with open(…): pass[移动端访问我的博客](/移动端访问我的博客.md) 它会帮助我们安全的关闭链接，但我不知道它的工作原理，下面让我们来仔细分析一下。我们先展示一段代码：123456789101112131415class MyResource: def __enter__(self): print('connect to resource') return self def __exit__(self, exc_type, exc_val, exc_tb): if exc_tb: print('process exception') else: print('no exception') print('close resource connection') return True def query(self): print('query data')with MyResource() as resource: resource.query() 上面代码执行的结果如下：1234connect to resourcequery datano exceptionclose resource connection 由执行的结果我们知道with语句的执行顺序 会首先调用类的enter方法，并将 enter返回的值赋给 as后的对象 执行with语句中的代码 执行 exit中的代码，这里相当于finally的作用 我们发现 exit函数有3个参数，我们来分析一下这几个参数的作用，我们修改部分代码如下：123with MyResource() as resource: 1 / 0 resource.query() 执行得到下面的结果：123connect to resourceprocess exceptionclose resource connection 显然这三个参数保存的是异常信息，我们可以在 exit中处理with中的异常信息。值得注意的是 exit的返回值，返回False，会继续在with外部抛出异常，返回True，不会继续在with外部抛出异常，什么都不返回相当于返回False。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask学习与Python进阶\_1]]></title>
    <url>%2F2018%2F03%2F30%2FFlask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6_1%2F</url>
    <content type="text"><![CDATA[Flask是基于Python的Web框架，我们主要通过学习Flask的基础知识来学习Python进阶知识。 使用pipenv 使用pipenv创建虚拟环境1` pip install pipenv ` 在自己的项目目录下创建虚拟环境，这个虚拟环境和项目是绑定的1`pipenv install `我执行上面的命令时报错了，好像是字符编码的问题，查询了一下，执行下面的2个命令就可以解决。12`export LANG=en_US.UTF-8export LC_ALL=en_US.UTF-8 ` 创建完虚拟环境后，我们需要的是启动虚拟环境1` pipenv shell ` 这里虚拟环境的主要作用是区分开项目的环境，每个项目版本、使用的包可能都不一样，区分开来更加方便。安装flask1`pipenv install flask `&gt; 退出虚拟环境1`exit `&gt; 查看包的依赖关系1` pipenv graph `&gt; 在虚拟环境下执行下面的命令，可以找到当前虚拟环境的目录1`pipenv --venv `&gt; 创建一个简单的Flask项目，下面是最简单的Flask代码，就是下面简单的代码，我们就能运行起我们的Web服务。123456` from flask import Flaskapp = Flask(__name__) # 实例化Flask对象@app.route('/hello') # 定义一个视图函数def hello():return "Hello, wsd" app.run() # 启动web服务器 ` 可以调试模式，修改代码就可以自动重启服务器，同时可以显示详细的异常信息1`app.run(debug=True) `&gt; 在介绍另一种路由注册方式，比较而言第一种更加方便。1234` def hello():# 基于类的视图（即插视图）=\&gt; 不是重点return "Hello, wsd"app.add_url_rule('/hello', view_func=hello) `&gt; 在这里有一个想问题，我们写Python代码时经常会写下面的代码：12`if __name__ == '__main__': app.run(host='0.0.0.0', debug=app.config['DEBUG']()) # 启动web服务器 ` 这里为什么要写 if name == ‘main’呢？在一般的Python代码里，原因是确保if内的语句只在当前文件作为入口文件时执行，不会在其他模块导入时执行而在Flask项目中，除了上面的原因，还因为Python Web项目的生产环境一般为nginx + uwsgi, if下面的语句是启用了一个Flask自带的服务器，在生产环境下不会启动自带的服务器，如果没有if判断生产环境下就会执行下面的语句，就会启动flask默认的服务器]]></content>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端访问我的博客]]></title>
    <url>%2F2018%2F03%2F30%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>移动端访问</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些想法]]></title>
    <url>%2F2018%2F03%2F30%2F%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写一些自己的想法 由于上了研究生，接触了很多深入的知识，也不可能仅仅停留在使用上了，在这个博客里，我会更新我的学习收获，大致的目录如下： 安全查询方面的内容和代码。 Flask框架核心与Python的使用。 英语学习的收获和感悟。 线性代数等数学知识的深入。 机器学习能知识。希望能不断完善自己的知识。]]></content>
      <categories>
        <category>想法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于我]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[写一些自己的想法 现在在西安读研究生，希望能总结下自己的学习内容。 可以访问我的邮箱:wwg377655460@126.comQQ:377655460希望可以多多交流。]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[timeline]]></title>
    <url>%2Ftimeline%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>

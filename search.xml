<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2018/04/02/configs/sorts/"/>
      <url>/2018/04/02/configs/sorts/</url>
      <content type="html"><![CDATA[{"":["flask学习与python进阶-3-进程与线程.md","flask学习与python进阶-2-with语句详解.md","flask学习与python进阶_1.md","移动端访问我的博客.md","一些想法.md","移动端访问我的博客","flask学习与python进阶-3-进程与线程","flask学习与python进阶-2-with语句详解","flask学习与python进阶_1"],"__positions":{"flask学习与python进阶-3-进程与线程.md":1,"flask学习与python进阶_1.md":3,"flask学习与python进阶-3-进程与线程":7,"flask学习与python进阶-2-with语句详解.md":2,"flask学习与python进阶_1":9,"移动端访问我的博客.md":4,"一些想法.md":5,"flask学习与python进阶-2-with语句详解":8,"移动端访问我的博客":6},"__raw_positions":{"flask学习与python进阶-3-进程与线程.md":1,"flask学习与python进阶_1.md":3,"flask学习与python进阶-3-进程与线程":7,"flask学习与python进阶-2-with语句详解.md":2,"flask学习与python进阶_1":9,"移动端访问我的博客.md":4,"一些想法.md":5,"flask学习与python进阶-2-with语句详解":8,"移动端访问我的博客":6}}]]></content>
      
      
    </entry>
    
    <entry>
      <title>Flask学习与Python进阶-3-进程与线程</title>
      <link href="/2018/04/02/Flask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6-3-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/04/02/Flask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6-3-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><blockquote><p> 进程是竞争计算机资源的基本单位，对于单核CPPU，同一时间永远只能执行一个应用程序，它会在不同的应用程序进程之间切换。</p></blockquote><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><blockquote><p> 线程是进程的一部分<br>1个进程 =&gt; 多个线程<br>CPU越来越强，我们需要更小的单元来管理CPU的资源。<br>线程 =&gt; 利用CPU执行代码，不能够拥有资源，但是可以访问资源（自己所在的进程）它的切换很快<br>进程 =&gt; 分配资源</p></blockquote><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><blockquote><p>  在Python中启动多线程<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am a thread"</span>)</span><br><span class="line">    t = threading.current_thread()</span><br><span class="line">    print(t.getName())</span><br><span class="line">print(<span class="string">"This is a test"</span>)</span><br><span class="line">t = threading.current_thread()</span><br><span class="line">print(t.getName())</span><br><span class="line">new_t = threading.Thread(target=worker, name=<span class="string">"New Thread"</span>)</span><br><span class="line">new_t.start()</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p> 上面代码执行的结果如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is <span class="selector-tag">a</span> test</span><br><span class="line">MainThread</span><br><span class="line">I am <span class="selector-tag">a</span> thread</span><br><span class="line">New Thread</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p> 多线程的编程是为了更加充分的利用CPU的性能优势</p></blockquote><blockquote><p> 但是Python<strong>不能</strong>充分的利用CPU的性能优势 :(<br> 原因是因为Python有一个GIL（全局解释器锁），它会让Python代码同一时刻只能在一个核上执行同一的线程，Python为什么要设计这样一个锁呢？<br>因为Python为了让代码更加简洁，在解释器的层面加了一个锁，不需要程序员编写细粒度的锁，但是这只是在一定程度上保证了线程安全。但是在一些特殊场合，比如<code>a+=1</code>，在Python解释器中可能会被翻译成多段bytecode，虽然有GIL，但是这多段bytecode不能保证不能中断。</p><p>值得注意的是Python的多线程在IO密集型程序中是非常有帮助的，因为GIL只是让CPU不能在同一时间执行多个线程，但是IO密集型程序大部分时间都在对数据查询上（需要等待），这部分完全可以并发执行，这时Python的多线程就非常有作用了。</p></blockquote><h2 id="Flask中的多线程"><a href="#Flask中的多线程" class="headerlink" title="Flask中的多线程"></a>Flask中的多线程</h2><h3 id="Flask如何做到多线程"><a href="#Flask如何做到多线程" class="headerlink" title="Flask如何做到多线程"></a>Flask如何做到多线程</h3><blockquote><p>开启多线程<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, debug=app.config[<span class="string">'DEBUG'</span>], threaded=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>但是Flask如何同时处理多个请求呢？多线程？<br>Flask内部使用字典（Local对象 werkzeug的基础库）来储存多个线程（通过线程号）=&gt; 线程隔离<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">my_obj = A()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 新线程</span></span><br><span class="line">    my_obj.b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">new_t = threading.Thread(target=worker, name=<span class="string">'New Thread'</span>)</span><br><span class="line">new_t.start()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">print(my_obj.b)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p> 上述代码输出结果为2，这里是因为对象A不是线程隔离的。<br>修改代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">my_obj = Local()</span><br><span class="line">my_obj.b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 新线程</span></span><br><span class="line">    my_obj.b = <span class="number">2</span></span><br><span class="line">    print(<span class="string">'in new thread b is:'</span> + str(my_obj.b))</span><br><span class="line"></span><br><span class="line">new_t = threading.Thread(target=worker, name=<span class="string">'New Thread'</span>)</span><br><span class="line">new_t.start()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'in main thread b is:'</span> + str(my_obj.b))</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> new thread b <span class="keyword">is</span>:<span class="number">2</span></span><br><span class="line"><span class="keyword">in</span> main thread b <span class="keyword">is</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p> 这里的主线程中的b不会被其他线程修改，这是因为Local对象是线程隔离的，正如我们上面说的Local是通过线程号，使用字典来做到线程隔离的。</p></blockquote><blockquote><p>Local源码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Local</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'__storage__'</span>, <span class="string">'__ident_func__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        object.__setattr__(self, <span class="string">'__storage__'</span>, &#123;&#125;)</span><br><span class="line">        object.__setattr__(self, <span class="string">'__ident_func__'</span>, get_ident)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.__storage__.items())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, proxy)</span>:</span></span><br><span class="line">        <span class="string">"""Create a proxy for a name."""</span></span><br><span class="line">        <span class="keyword">return</span> LocalProxy(self, proxy)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__release_local__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__storage__.pop(self.__ident_func__(), <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        ident = self.__ident_func__() <span class="comment"># 获取线程号</span></span><br><span class="line">        storage = self.__storage__</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            storage[ident][name] = value</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            storage[ident] = &#123;name: value&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">del</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="Flask中的线程隔离栈：LocalStack"><a href="#Flask中的线程隔离栈：LocalStack" class="headerlink" title="Flask中的线程隔离栈：LocalStack"></a>Flask中的线程隔离栈：LocalStack</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalStack</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">        &gt;&gt;&gt; ls = LocalStack()</span><br><span class="line">        &gt;&gt;&gt; ls.push(<span class="number">42</span>)</span><br><span class="line">        &gt;&gt;&gt; ls.top</span><br><span class="line">        <span class="number">42</span></span><br><span class="line">        &gt;&gt;&gt; ls.push(<span class="number">23</span>)</span><br><span class="line">        &gt;&gt;&gt; ls.top</span><br><span class="line">        <span class="number">23</span></span><br><span class="line">        &gt;&gt;&gt; ls.pop()</span><br><span class="line">        <span class="number">23</span></span><br><span class="line">        &gt;&gt;&gt; ls.top</span><br><span class="line">        <span class="number">42</span></span><br><span class="line">    .. versionadded:: <span class="number">0.6</span><span class="number">.1</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __init__(self):</span></span><br><span class="line"><span class="string">        self._local = Local()</span></span><br><span class="line"><span class="string">    def __release_local__(self):</span></span><br><span class="line"><span class="string">        self._local.__release_local__()</span></span><br><span class="line"><span class="string">    def _get__ident_func__(self):</span></span><br><span class="line"><span class="string">        return self._local.__ident_func__</span></span><br><span class="line"><span class="string">    def _set__ident_func__(self, value):</span></span><br><span class="line"><span class="string">        object.__setattr__(self._local, '__ident_func__', value)</span></span><br><span class="line"><span class="string">    __ident_func__ = property(_get__ident_func__, _set__ident_func__)</span></span><br><span class="line"><span class="string">    del _get__ident_func__, _set__ident_func__</span></span><br><span class="line"><span class="string">    def __call__(self):</span></span><br><span class="line"><span class="string">        def _lookup():</span></span><br><span class="line"><span class="string">            rv = self.top</span></span><br><span class="line"><span class="string">            if rv is None:</span></span><br><span class="line"><span class="string">                raise RuntimeError('object unbound')</span></span><br><span class="line"><span class="string">            return rv</span></span><br><span class="line"><span class="string">        return LocalProxy(_lookup)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def push(self, obj):</span></span><br><span class="line"><span class="string">        """</span>Pushes a new item to the stack<span class="string">"""</span></span><br><span class="line"><span class="string">        rv = getattr(self._local, 'stack', None)</span></span><br><span class="line"><span class="string">        if rv is None:</span></span><br><span class="line"><span class="string">            self._local.stack = rv = []</span></span><br><span class="line"><span class="string">        rv.append(obj)</span></span><br><span class="line"><span class="string">        return rv</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def pop(self):</span></span><br><span class="line"><span class="string">        """</span>Removes the topmost item <span class="keyword">from</span> the stack, will <span class="keyword">return</span> the</span><br><span class="line">        old value <span class="keyword">or</span> `<span class="keyword">None</span>` <span class="keyword">if</span> the stack was already empty.</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        stack = getattr(self._local, 'stack', None)</span></span><br><span class="line"><span class="string">        if stack is None:</span></span><br><span class="line"><span class="string">            return None</span></span><br><span class="line"><span class="string">        elif len(stack) == 1:</span></span><br><span class="line"><span class="string">            release_local(self._local)</span></span><br><span class="line"><span class="string">            return stack[-1]</span></span><br><span class="line"><span class="string">        else:</span></span><br><span class="line"><span class="string">            return stack.pop()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @property</span></span><br><span class="line"><span class="string">    def top(self):</span></span><br><span class="line"><span class="string">        """</span>The topmost item on the stack.  If the stack <span class="keyword">is</span> empty,</span><br><span class="line">        `<span class="keyword">None</span>` <span class="keyword">is</span> returned.</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        try:</span></span><br><span class="line"><span class="string">            return self._local.stack[-1]</span></span><br><span class="line"><span class="string">        except (AttributeError, IndexError):</span></span><br><span class="line"><span class="string">            return None</span></span><br></pre></td></tr></table></figure><blockquote><p> LocalStack为我们封装了push(), pop(), top()三个函数，实现了线程隔离栈<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">my_statck = LocalStack()</span><br><span class="line">my_statck.push(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'in main after push, value is:'</span> + str(my_statck.top))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 新线程</span></span><br><span class="line">    print(<span class="string">'in new thread before push, value is:'</span> + str(my_statck.top))</span><br><span class="line">    my_statck.push(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'in new thread after push, value is:'</span> + str(my_statck.top))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new_t = threading.Thread(target=worker, name=<span class="string">'New Thread'</span>)</span><br><span class="line">new_t.start()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程</span></span><br><span class="line">print(<span class="string">'finally, in main thread value is:'</span> + str(my_statck.top))</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p> 上述代码执行结果为：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> main after push, <span class="keyword">value</span> <span class="keyword">is</span>:<span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> <span class="keyword">new</span> thread before push, <span class="keyword">value</span> <span class="keyword">is</span>:None</span><br><span class="line"><span class="keyword">in</span> <span class="keyword">new</span> thread after push, <span class="keyword">value</span> <span class="keyword">is</span>:<span class="number">2</span></span><br><span class="line"><span class="keyword">finally</span>, <span class="keyword">in</span> main thread <span class="keyword">value</span> <span class="keyword">is</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p> 可以看出LocalStack是线程隔离的。<br>Flask使用LocalStack隔离的是AppContext和Request Context(Request对象包含在上下文中)，Flask需要用一个变量名指向多个线程创建的多个变量</p></blockquote><h3 id="Flask使用线程隔离的意义"><a href="#Flask使用线程隔离的意义" class="headerlink" title="Flask使用线程隔离的意义"></a>Flask使用线程隔离的意义</h3><blockquote><p>Flask使用线程隔离的意义在于：<strong>使当前线程能正确引用到他自己所创建的对象，而不是引用到其他线程所创建的对象。</strong><br>需要注意Flask中的核心对象app只有一个，他是在入口文件中创建的，只会被创建一次，每一个进程使用的都是同一个地址，同一个app对象。所以这里app可以用来让所有请求共享同一份数据（网站访问计数），但是这是不推荐的（线程安全问题）。<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 以线程ID号作为<span class="function"><span class="title">key</span>的字典 -&gt;</span> L<span class="function"><span class="title">ocal</span> -&gt;</span> LocalStock</span><br><span class="line"></span><br><span class="line"># A<span class="function"><span class="title">ppContext</span> RequestContext -&gt;</span> LocalStack</span><br><span class="line"></span><br><span class="line"># F<span class="function"><span class="title">lask</span> -&gt;</span> A<span class="function"><span class="title">ppContext</span>        Request -&gt;</span> RequestContext</span><br><span class="line"></span><br><span class="line"># <span class="function"><span class="title">current_app</span> -&gt;</span> (LocalStack.top = AppContext   top.app = Flask 只有一个)</span><br><span class="line"></span><br><span class="line"># <span class="function"><span class="title">request</span> -&gt;</span> (LocalStack.top = RequestContext   top.request = Request 多个)</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> Flask </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Flask学习与Python进阶-2-With语句详解</title>
      <link href="/2018/04/02/Flask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6-2-With%E8%AF%AD%E5%8F%A5%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/04/02/Flask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6-2-With%E8%AF%AD%E5%8F%A5%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="Python中With的用法"><a href="#Python中With的用法" class="headerlink" title="Python中With的用法"></a>Python中With的用法</h3><blockquote><p>在编写Python代码，需要链接数据库或打开文件时，我经常会使用<strong>with</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(…):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">[移动端访问我的博客](/移动端访问我的博客.md)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>它会帮助我们安全的关闭链接，但我不知道它的工作原理，下面让我们来仔细分析一下。<br>我们先展示一段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'connect to resource'</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span> </span><br><span class="line">        <span class="keyword">if</span> exc_tb:</span><br><span class="line">            print(<span class="string">'process exception'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'no exception'</span>)</span><br><span class="line">            print(<span class="string">'close resource connection'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'query data'</span>)</span><br><span class="line"><span class="keyword">with</span> MyResource() <span class="keyword">as</span> resource:</span><br><span class="line">    resource.query()</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>上面代码执行的结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connect to resource</span><br><span class="line">query data</span><br><span class="line">no exception</span><br><span class="line">close resource connection</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>由执行的结果我们知道<strong>with</strong>语句的执行顺序</p><ol><li>会首先调用类的<strong><strong>enter</strong></strong>方法，并将<strong> <strong>enter</strong></strong>返回的值赋给<strong> as</strong>后的对象</li><li>执行<strong>with</strong>语句中的代码</li><li>执行<strong> <strong>exit</strong></strong>中的代码，这里相当于<strong>finally</strong>的作用</li></ol></blockquote><blockquote><p>我们发现<strong> <strong>exit</strong></strong>函数有3个参数，我们来分析一下这几个参数的作用，我们修改部分代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> MyResource() <span class="keyword">as</span> resource:</span><br><span class="line">     <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">     resource.query()</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>执行得到下面的结果：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connect <span class="keyword">to</span> resource</span><br><span class="line">process exception</span><br><span class="line">close<span class="built_in"> resource </span>connection</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>显然这三个参数保存的是异常信息，我们可以在<strong> <strong>exit</strong></strong>中处理<strong>with</strong>中的异常信息。<br><strong>值得注意的是 <strong>exit</strong>的返回值，返回False，会继续在with外部抛出异常，返回True，不会继续在with外部抛出异常，什么都不返回相当于返回False。</strong></p></blockquote>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> Flask </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Flask学习与Python进阶-1-基础知识</title>
      <link href="/2018/03/30/Flask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6_1/"/>
      <url>/2018/03/30/Flask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6_1/</url>
      <content type="html"><![CDATA[<blockquote><p>Flask是基于Python的Web框架，我们主要通过学习Flask的基础知识来学习Python进阶知识。</p></blockquote><h2 id="使用pipenv"><a href="#使用pipenv" class="headerlink" title="使用pipenv"></a>使用pipenv</h2><blockquote><p> 使用pipenv创建虚拟环境<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">` pip install pipenv</span><br></pre></td></tr></table></figure></p></blockquote><p>`</p><blockquote><p> 在自己的项目目录下创建虚拟环境，这个虚拟环境和项目是绑定的<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`pipenv install</span><br></pre></td></tr></table></figure></p></blockquote><p>`<strong>我执行上面的命令时报错了，好像是字符编码的问题，查询了一下，执行下面的2个命令就可以解决。</strong><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`<span class="builtin-name">export</span> <span class="attribute">LANG</span>=en_US.UTF-8</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">LC_ALL</span>=en_US.UTF-8</span><br></pre></td></tr></table></figure></p><p>`</p><blockquote><p> 创建完虚拟环境后，我们需要的是启动虚拟环境<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">` pipenv <span class="keyword">shell</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p></blockquote><p>`</p><blockquote><p> 这里虚拟环境的主要作用是区分开项目的环境，每个项目版本、使用的包可能都不一样，区分开来更加方便。<br>安装flask<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`pipenv install flask</span><br></pre></td></tr></table></figure></p></blockquote><p>`&gt;  退出虚拟环境<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">exit</span></span><br></pre></td></tr></table></figure></p><p>`&gt;  查看包的依赖关系<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">` pipenv graph</span><br></pre></td></tr></table></figure></p><p>`&gt;  在虚拟环境下执行下面的命令，可以找到当前虚拟环境的目录<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`pipenv <span class="comment">--venv</span></span><br></pre></td></tr></table></figure></p><p>`&gt; 创建一个简单的Flask项目，下面是最简单的Flask代码，就是下面简单的代码，我们就能运行起我们的Web服务。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">` <span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)  <span class="comment"># 实例化Flask对象</span></span><br><span class="line"><span class="meta">@app.route('/hello')  #  定义一个视图函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello, wsd"</span></span><br><span class="line"> app.run()  <span class="comment"># 启动web服务器</span></span><br></pre></td></tr></table></figure></p><p>`</p><blockquote><p> 可以调试模式，修改代码就可以自动重启服务器，同时可以显示详细的异常信息<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`app.<span class="builtin-name">run</span>(<span class="attribute">debug</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p></blockquote><p>`&gt;  在介绍另一种路由注册方式，比较而言第一种更加方便。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">` <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line"><span class="comment"># 基于类的视图（即插视图）=\&gt; 不是重点</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello, wsd"</span></span><br><span class="line">app.add_url_rule(<span class="string">'/hello'</span>, view_func=hello)</span><br></pre></td></tr></table></figure></p><p>`&gt; 在这里有一个想问题，我们写Python代码时经常会写下面的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: </span><br><span class="line">app.run(host=<span class="string">'0.0.0.0'</span>, debug=app.config[<span class="string">'DEBUG'</span>]())  <span class="comment"># 启动web服务器</span></span><br></pre></td></tr></table></figure></p><p>`</p><blockquote><p>这里为什么要写<strong> if <strong>name</strong> == ‘<strong>main</strong>’</strong>呢？<br>在一般的Python代码里，原因是确保if内的语句只在当前文件作为入口文件时执行，不会在其他模块导入时执行<br>而在Flask项目中，除了上面的原因，还因为Python Web项目的生产环境一般为nginx + uwsgi, if下面的语句是启用了一个Flask自带的服务器，在生产环境下不会启动自带的服务器，如果没有if判断生产环境下就会执行下面的语句，就会启动flask默认的服务器</p></blockquote>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> Flask </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>移动端访问我的博客</title>
      <link href="/2018/03/30/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/03/30/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p><img src="/2018/03/30/移动端访问我的博客/url.png" alt="二维码"></p>]]></content>
      
      <categories>
          
          <category> 移动端访问 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一些想法</title>
      <link href="/2018/03/30/%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/"/>
      <url>/2018/03/30/%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="写一些自己的想法"><a href="#写一些自己的想法" class="headerlink" title="写一些自己的想法"></a>写一些自己的想法</h3><blockquote><p>由于上了研究生，接触了很多深入的知识，也不可能仅仅停留在使用上了，在这个博客里，我会更新我的学习收获，大致的目录如下：</p><ol><li>安全查询方面的内容和代码。</li><li>Flask框架核心与Python的使用。</li><li>英语学习的收获和感悟。</li><li>线性代数等数学知识的深入。</li><li>机器学习能知识。<br>希望能不断完善自己的知识。</li></ol></blockquote>]]></content>
      
      <categories>
          
          <category> 想法 </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h3 id="写一些自己的想法"><a href="#写一些自己的想法" class="headerlink" title="写一些自己的想法"></a>写一些自己的想法</h3><blockquote><p>现在在西安读研究生，希望能总结下自己的学习内容。</p></blockquote><p><strong><br>可以访问我的邮箱:<a href="mailto:wwg377655460@126.com" target="_blank" rel="noopener">wwg377655460@126.com</a><br>QQ:377655460<br>希望可以多多交流。</strong></p>]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>

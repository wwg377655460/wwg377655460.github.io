<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flask学习与Python进阶-5-用户管理]]></title>
    <url>%2F2018%2F04%2F11%2FFlask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6-5-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Flask中的用户管理用户模型的定义12345678910111213141516171819202122232425class User(UserMixin, Base): id = Column(Integer, primary_key=True) nickname = Column(String(24), nullable=False) phone_number = Column(String(18), unique=True) _password = Column('password', String(length=128), nullable=False) email = Column(String(50), unique=True, nullable=False) confirmed = Column(Boolean, default=False) beans = Column(Float, default=0) send_counter = Column(Integer, default=0) receive_counter = Column(Integer, default=0) wx_open_id = Column(String(50)) wx_name = Column(String(32)) # 对数据进行预处理 # 还可以对数据做只读只写的限制 @property def password(self): return self._password @password.setter def password(self, raw): self._password = generate_password_hash(raw) def check_password(self, raw): return check_password_hash(self._password, raw) 简单的就不说了，我们看到上面的代码，应该对下面几点有一些疑问。 两个password函数 这里两个函数是为了处理密码字段，我们知道我们在数据库中储存的密码数据都是加密后的，我们对用户提交的数据分装时可能会使用下面的代码将form对象映射成User对象1234567user = User()user.set_attrs(form.data)===================== def set_attrs(self, attrs_dict): for key, value in attrs_dict.items(): if hasattr(self, key) and key != 'id': setattr(self, key, value) 这个set_attrs函数我们放在所有对象都继承了的Base类中，这个类可以存储一些共有字段和方法。上面的set_attrs也会将密码字段映射过去，但我们需要的是加密后的密码，所有我们使用@property构造一个password字段，并使用 @password.setter限制它的赋值，这样我们就将加密操作直接封装了，调用者看不到任何痕迹。 check_password函数 这个函数判断传入的密码加密后是否和原对象的密码相同，这属于方法的封装，我们要注意要把User对象应该有的方法都封装进来。 UserMixin 这个会在用户权限管理插件里讲。 超级强大的用户权限管理插件flask_login安装1pipenv install falsk_login 基本配置123456# 主文件login_manager = LoginManager()... login_manager.init_app(app)login_manager.login_view = 'web.login' # 告诉插件我们登录的视图函数,未授权时会自动跳转到该界面，并flash一条消息login_manager.login_message = '请先登录或注册' # 在跳转后的url中有next指向前一个页面，可以在login中编写逻辑 基本使用 我们在使用时只需使用login_user(user, remember=True)就可以保存用户的信息在cookie中，具体时间需要修改配置项，默认是365天，remember=True设定了cookie不是关闭浏览器就失效。这里插件如何知道要把User的什么值储存在cookie中呢？这就要用到我们上面没有解释的UserMixin，它帮我们实现了如get_id函数等方法，使插件可以获取能表示用户身份的参数，但是要只有UserMixin中默认的参数是id，但是如果不是用id表示身份，就需要重写get_id()方法123...def get_id(self): return self.myId 限制未登录的用户访问 我们只需在对应的路由函数上加上@login_required就可以了1234@web.route('/my/gifts')@login_required def my_gifts(): return 'My Gifts' 这里要让框架起作用还要告诉框架如何查询对应的用户（这时Cookie中只有id，框架要判断存不存在这样的用户呀，毕竟cookie是可以修改的） 还需要编写一个函数，在User对象中导入1from app import login_manager 并在与User类平级上创建函数123456class User(...) ...@login_manager.user_loaderdef get_user(uid): return User.query.get(int(uid)) 上述方法指定了如何判断用户是否存在 这时未登录的用户访问gift页面就会跳转到登录页面（前面有设定），我们还要在用户登录后再跳转到用户最开始访问的页面呀，框架也帮我们想好了，他会在登录页面后加上next=…，带上开始访问的地址，我们只需要next = request.args.get(&#39;next&#39;)就可以在用户登录后获取到这个地址，请注意这个地方存在重定向攻击的风险，我们需要判断next后的地址不会跳转到奇怪的地方。12345...next = request.args.get('next')if not next or not next.startswith('/'): next = url_for('web.index')return redirect(next) 表单验证 Flask中的表单算是比较简单的了，我们简单的介绍一下 表单模型的构建123456789101112131415161718192021class RegisterForm(Form): email = StringField(validators=[DataRequired(), Length(8, 64), Email(message='电子邮箱不符合规范')]) password = PasswordField(validators=[ DataRequired(message='密码不可以为空，请输入你的密码'), Length(6, 32) ]) nickname = StringField(validators=[ DataRequired(), Length(2, 10, message='昵称至少需要两个字符，最多10个字符') ]) def validate_email(self, field): # wtf会对 validate_后的字段自动校验 # db.session if User.query.filter_by(email=field.data).first(): raise ValidationError('电子邮件已被注册') def validate_nickname(self, field): # wtf会对 validate_后的字段自动校验 # db.session if User.query.filter_by(nickname=field.data).first(): raise ValidationError('昵称已经存在') 要注意后面的几个方法，框架会自动检测validate_后的值，在这里我们可以查询数据库等操作。 简单的使用12345678form = RegisterForm(request.form)if request.method == 'POST' and form.validate(): user = User() user.set_attrs(form.data) db.session.add(user) db.session.commit() redirect(url_for('web.login')) # 接收end_pointreturn render_template('auth/register.html', form=form) Flask中的数据库查询操作可以简单了解一下。]]></content>
      <categories>
        <category>Python</category>
        <category>Flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask学习与Python进阶-5-页面的展示]]></title>
    <url>%2F2018%2F04%2F11%2FFlask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6-5-%E9%A1%B5%E9%9D%A2%E4%B8%8E%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[页面的展示Flask中页面的逻辑 Flask自带Jinjia模板引擎来渲染页面，关于Jinjia的基本用法可以访问官网下面我们仔细说明一下一些需要注意的细节： 渲染页面 服务端通过render_template函数返回渲染后的页面，该函数起到渲染的作用12...return render_template('auth/login.html', form=form) 上述代码，通过form对象来天聪login.html模板，在login.html中我们使用下面的方式填充数据12&#123;&#123; form.data['email'] &#125;&#125; # 从form中取出数据&#123;&#123; book.image &#125;&#125; Jinjia中的管道 在book没有summary属性时才会显示空1&#123;&#123; book.summary | default('') &#125;&#125; 在book.summary为空, None时显示空1&#123;&#123; book.summary | default('', true) &#125;&#125; 管道可以理解为一层一层向下传递，当前一端为False时向下一层传递，这里False比较特殊，可以理解为存不存在，而不是值是不是False。所以需要在default中加入True表示判断的是值是False(None, ‘’) 反向构建Url 前面我们提过在Flask创建Url映射时有一个endpoint，默认是蓝图名称+函数名称。在反向构建Url时就可以看到他的作用，正如他的名称，他可以帮助我们通过endpoint找到对应的Url，我们通过下面的代码来生成endpoint为web.forget_password_reques来构建他的Url1&#123;&#123; url_for('web.forget_password_request') &#125;&#125; 反向构建Url可以帮助我们不必在模板代码中硬编码我们的地址。这里方向构建Url常用在静态资源的访问上，下面的代码就是构建对应css文件的代码1&#123;&#123;url_for('static',filename = 'css/search-result.css')&#125;&#125; 这里有一个疑问，我们什么时候定义了一个static的endpoint的，其实Flask帮助我们定义了Flask处理静态函数的源码1234567891011121314151617def __init__(self, import_name, static_path=None, static_url_path=None, static_folder='static', template_folder='templates', &lt;=== 注意有一个默认值 instance_path=None, instance_relative_config=False, root_path=None):...if self.has_static_folder: self.add_url_rule(self.static_url_path + '/&lt;path:filename&gt;', endpoint='static', view_func=self.send_static_file) ====================&gt; self.static_url_path...def _get_static_url_path(self): if self._static_url_path is not None: return self._static_url_path if self.static_folder is not None: return '/' + os.path.basename(self.static_folder) 我们可以通过app = Flask(__name__, static_folder=&#39;statics&#39;)来设定静态文件的目录，还有有一个send_static_file函数，我们可以利用这个函数来限制静态文件的读取（积分下载等）。 消息闪现 消息闪现可以帮助我们快速向模板传递提示信息，后面不需要返回值了。12345678910flash('搜索的关键字不符合要求，请重新输入关键字')flash('hello, wsd', category='msg')==================================&#123;% set messages = get_flashed_messages(category_filter=["msg"]) %&#125; # 可以通过category_filter指定要读取的flash &lt;b&gt;&#123;&#123; messages &#125;&#125;&lt;/b&gt; # 可以用遍历语句遍历 &#123;# with 缩小了变量的作用域#&#125; &#123;% with messages = get_flashed_messages() %&#125; &#123;&#123; messages &#125;&#125; &#123;% endwith %&#125;]]></content>
      <categories>
        <category>Python</category>
        <category>Flask</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F03%2Fconfigs%2Fsorts%2F</url>
    <content type="text"><![CDATA[{"":["flask学习与python进阶-5-用户管理.md","flask学习与python进阶-5-页面与用户.md","flask学习与python进阶_1.md","机器学习系列-1-什么是机器学习.md","flask学习与python进阶-4-面向对象.md","flask学习与python进阶-3-进程与线程.md","flask学习与python进阶-2-with语句详解.md","移动端访问我的博客.md","一些想法.md","flask学习与python进阶-5-用户管理","flask学习与python进阶-5-页面与用户","机器学习系列-1-什么是机器学习","flask学习与python进阶-4-面向对象","移动端访问我的博客","flask学习与python进阶-3-进程与线程","flask学习与python进阶-2-with语句详解","flask学习与python进阶_1"],"__positions":{"flask学习与python进阶-3-进程与线程.md":6,"flask学习与python进阶_1.md":3,"flask学习与python进阶-3-进程与线程":15,"flask学习与python进阶-5-页面与用户":11,"机器学习系列-1-什么是机器学习":12,"flask学习与python进阶-4-面向对象":13,"flask学习与python进阶-2-with语句详解.md":7,"flask学习与python进阶-5-用户管理":10,"flask学习与python进阶-5-页面与用户.md":2,"flask学习与python进阶-5-用户管理.md":1,"flask学习与python进阶-4-面向对象.md":5,"flask学习与python进阶_1":17,"移动端访问我的博客.md":8,"一些想法.md":9,"flask学习与python进阶-2-with语句详解":16,"移动端访问我的博客":14,"机器学习系列-1-什么是机器学习.md":4},"__raw_positions":{"flask学习与python进阶_1":17,"flask学习与python进阶-3-进程与线程.md":6,"flask学习与python进阶_1.md":3,"flask学习与python进阶-3-进程与线程":15,"flask学习与python进阶-5-页面与用户":11,"机器学习系列-1-什么是机器学习":12,"flask学习与python进阶-2-with语句详解.md":7,"flask学习与python进阶-5-页面与用户.md":2,"flask学习与python进阶-5-用户管理.md":1,"机器学习系列-1-什么是机器学习.md":4,"flask学习与python进阶-2-with语句详解":16,"flask学习与python进阶-5-用户管理":10,"移动端访问我的博客.md":8,"一些想法.md":9,"flask学习与python进阶-4-面向对象":13,"移动端访问我的博客":14,"flask学习与python进阶-4-面向对象.md":5}}]]></content>
  </entry>
  <entry>
    <title><![CDATA[机器学习系列-1-什么是机器学习]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是机器学习？输入大量学习资料 -&gt; 机器学习算法 -&gt; 学习得到执行任务的算法（模型）-&gt; 输入结果 各种名词之间的关系]]></content>
      <categories>
        <category>Python</category>
        <category>ML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask学习与Python进阶-4-面向对象]]></title>
    <url>%2F2018%2F04%2F02%2FFlask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6-4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象&amp;伪面向对象 不是我们写了class就是面向对象了，如果一个类中大部分函数可以使用@classmethod, @staticmethod来修饰就是伪面向对象。 原始代码一1234567891011121314151617181920class YuShuBook: isbn_url = 'http://t.yushu.im/v2/book/isbn/&#123;&#125;' keyword_url = 'http://t.yushu.im/v2/book/search?q=&#123;&#125;&amp;count=&#123;&#125;&amp;start=&#123;&#125;' @classmethod def search_by_isbn(cls, isbn): url = cls.isbn_url.format(isbn) result = HTTP.get(url) # dict return result @classmethod def search_by_keyword(cls, keyword, page=1): url = cls.keyword_url.format(keyword, current_app.config['PER_PAGE'], cls.calculate_start(page)) result = HTTP.get(url) return result @staticmethod def calculate_start(page): return (page - 1) * current_app.config['PER_PAGE'] 重构一1234567891011121314151617181920212223242526272829class YuShuBook: isbn_url = 'http://t.yushu.im/v2/book/isbn/&#123;&#125;' keyword_url = 'http://t.yushu.im/v2/book/search?q=&#123;&#125;&amp;count=&#123;&#125;&amp;start=&#123;&#125;' def __init__(self): self.total = 0 self.books = [] def search_by_isbn(self, isbn): url = self.isbn_url.format(isbn) result = HTTP.get(url) self.__fill_single(result) def __fill_single(self, data): if data: self.total = 1 self.books.append(data) def search_by_keyword(self, keyword, page=1): url = self.keyword_url.format(keyword, current_app.config['PER_PAGE'], self.calculate_start(page)) result = HTTP.get(url) self.__fill_collection(result) def __fill_collection(self, data): self.total = data['total'] self.books = data['books'] def calculate_start(self, page): return (page - 1) * current_app.config['PER_PAGE'] 再来一个 原始代码二12345678910111213141516171819202122232425262728293031323334353637class BookViewModel: @classmethod def package_single(cls, data, keyword): returned = &#123; 'books': [], 'total': 0, 'keyword': keyword &#125; if data: returned['total'] = 1 returned['books'] = [cls.__cut_book_data(data)] return returned @classmethod def package_collection(cls, data, keyword): returned = &#123; 'books': [], 'total': 0, 'keyword': keyword &#125; if data: returned['total'] = data['total'] returned['books'] = [cls.__cut_book_data(book) for book in data['books']] return returned @classmethod def __cut_book_data(cls, data): book = &#123; 'title': data['title'], 'publisher': data['publisher'], 'pages': data['pages'] or '', 'author': '、'.join(data['author']), 'price': data['price'], 'summary': data['summary'] or '', 'image': data['image'] &#125; return book 重构二1234567891011121314151617181920class BookViewModel: def __init__(self, book): self.title = book['publisher'] self.publisher = book['publisher'], self.pages = book['pages'] or '', self.author = '、'.join(book['author']), self.price = book['price'], self.summary = book['summary'] or '', self.image = book['image']class BookCollection: def __init__(self): self.total = 0 self.books = [] self.keyword = '' def fill(self, yushu_book, keyword): self.total = yushu_book.total self.keyword = keyword self.books = [BookViewModel(book) for book in yushu_book.books] 我们来总结下如何写出面向对象的代码，我的想法是要明白类的职责，类应该有的数据和函数就要放在类中，不应该有的不要保存，将具体的处理细节封装起来，比如上面两个代码的重构，我们将数据通过init封装在了类中，不再返回，这里数据属于类，我使用数据时，直接使用类的对象就行了。 Tips 特别注意，一般我们需要把我们的对象序列化，但是对象中可能包含其他对象，不能直接使用json.dumps()，解决方法如下：1return json.dumps(books, default=lambda o: o.__dict__) 这里json.dumps()在序列化books时不知道如何处理时就会调用default中的函数，这种转移代码解释权的编程思想值得学习。]]></content>
      <categories>
        <category>Python</category>
        <category>Flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask学习与Python进阶-3-进程与线程]]></title>
    <url>%2F2018%2F04%2F02%2FFlask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6-3-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程与线程什么是进程 进程是竞争计算机资源的基本单位，对于单核CPPU，同一时间永远只能执行一个应用程序，它会在不同的应用程序进程之间切换。 什么是线程 线程是进程的一部分1个进程 =&gt; 多个线程CPU越来越强，我们需要更小的单元来管理CPU的资源。线程 =&gt; 利用CPU执行代码，不能够拥有资源，但是可以访问资源（自己所在的进程）它的切换很快进程 =&gt; 分配资源 多线程 在Python中启动多线程123456789def worker(): print("I am a thread") t = threading.current_thread() print(t.getName())print("This is a test")t = threading.current_thread()print(t.getName())new_t = threading.Thread(target=worker, name="New Thread")new_t.start() 上面代码执行的结果如下：1234This is a testMainThreadI am a threadNew Thread 多线程的编程是为了更加充分的利用CPU的性能优势 但是Python不能充分的利用CPU的性能优势 :( 原因是因为Python有一个GIL（全局解释器锁），它会让Python代码同一时刻只能在一个核上执行同一的线程，Python为什么要设计这样一个锁呢？因为Python为了让代码更加简洁，在解释器的层面加了一个锁，不需要程序员编写细粒度的锁，但是这只是在一定程度上保证了线程安全。但是在一些特殊场合，比如a+=1，在Python解释器中可能会被翻译成多段bytecode，虽然有GIL，但是这多段bytecode不能保证不能中断。 值得注意的是Python的多线程在IO密集型程序中是非常有帮助的，因为GIL只是让CPU不能在同一时间执行多个线程，但是IO密集型程序大部分时间都在对数据查询上（需要等待），这部分完全可以并发执行，这时Python的多线程就非常有作用了。 Flask中的多线程Flask如何做到多线程 开启多线程12if __name__ == '__main__': app.run(host='0.0.0.0', debug=app.config['DEBUG'], threaded=True) 但是Flask如何同时处理多个请求呢？多线程？Flask内部使用字典（Local对象 werkzeug的基础库）来储存多个线程（通过线程号）=&gt; 线程隔离12345678910111213class A: b = 1my_obj = A()def worker(): # 新线程 my_obj.b = 2new_t = threading.Thread(target=worker, name='New Thread')new_t.start()time.sleep(1)print(my_obj.b) 上述代码输出结果为2，这里是因为对象A不是线程隔离的。修改代码如下：12345678910111213my_obj = Local()my_obj.b = 1def worker(): # 新线程 my_obj.b = 2 print('in new thread b is:' + str(my_obj.b))new_t = threading.Thread(target=worker, name='New Thread')new_t.start()time.sleep(1)print('in main thread b is:' + str(my_obj.b)) 输出结果：12in new thread b is:2in main thread b is:1 这里的主线程中的b不会被其他线程修改，这是因为Local对象是线程隔离的，正如我们上面说的Local是通过线程号，使用字典来做到线程隔离的。 Local源码123456789101112131415161718192021222324252627282930313233343536class Local(object): __slots__ = ('__storage__', '__ident_func__') def __init__(self): object.__setattr__(self, '__storage__', &#123;&#125;) object.__setattr__(self, '__ident_func__', get_ident) def __iter__(self): return iter(self.__storage__.items()) def __call__(self, proxy): """Create a proxy for a name.""" return LocalProxy(self, proxy) def __release_local__(self): self.__storage__.pop(self.__ident_func__(), None) def __getattr__(self, name): try: return self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) def __setattr__(self, name, value): ident = self.__ident_func__() # 获取线程号 storage = self.__storage__ try: storage[ident][name] = value except KeyError: storage[ident] = &#123;name: value&#125; def __delattr__(self, name): try: del self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) Flask中的线程隔离栈：LocalStack12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class LocalStack(object): &gt;&gt;&gt; ls = LocalStack() &gt;&gt;&gt; ls.push(42) &gt;&gt;&gt; ls.top 42 &gt;&gt;&gt; ls.push(23) &gt;&gt;&gt; ls.top 23 &gt;&gt;&gt; ls.pop() 23 &gt;&gt;&gt; ls.top 42 .. versionadded:: 0.6.1 """ def __init__(self): self._local = Local() def __release_local__(self): self._local.__release_local__() def _get__ident_func__(self): return self._local.__ident_func__ def _set__ident_func__(self, value): object.__setattr__(self._local, '__ident_func__', value) __ident_func__ = property(_get__ident_func__, _set__ident_func__) del _get__ident_func__, _set__ident_func__ def __call__(self): def _lookup(): rv = self.top if rv is None: raise RuntimeError('object unbound') return rv return LocalProxy(_lookup) def push(self, obj): """Pushes a new item to the stack""" rv = getattr(self._local, 'stack', None) if rv is None: self._local.stack = rv = [] rv.append(obj) return rv def pop(self): """Removes the topmost item from the stack, will return the old value or `None` if the stack was already empty. """ stack = getattr(self._local, 'stack', None) if stack is None: return None elif len(stack) == 1: release_local(self._local) return stack[-1] else: return stack.pop() @property def top(self): """The topmost item on the stack. If the stack is empty, `None` is returned. """ try: return self._local.stack[-1] except (AttributeError, IndexError): return None LocalStack为我们封装了push(), pop(), top()三个函数，实现了线程隔离栈123456789101112131415161718my_statck = LocalStack()my_statck.push(1)print('in main after push, value is:' + str(my_statck.top))def worker(): # 新线程 print('in new thread before push, value is:' + str(my_statck.top)) my_statck.push(2) print('in new thread after push, value is:' + str(my_statck.top))new_t = threading.Thread(target=worker, name='New Thread')new_t.start()time.sleep(1)# 主线程print('finally, in main thread value is:' + str(my_statck.top)) 上述代码执行结果为：1234in main after push, value is:1in new thread before push, value is:Nonein new thread after push, value is:2finally, in main thread value is:1 可以看出LocalStack是线程隔离的。Flask使用LocalStack隔离的是AppContext和Request Context(Request对象包含在上下文中)，Flask需要用一个变量名指向多个线程创建的多个变量 Flask使用线程隔离的意义 Flask使用线程隔离的意义在于：使当前线程能正确引用到他自己所创建的对象，而不是引用到其他线程所创建的对象。需要注意Flask中的核心对象app只有一个，他是在入口文件中创建的，只会被创建一次，每一个进程使用的都是同一个地址，同一个app对象。所以这里app可以用来让所有请求共享同一份数据（网站访问计数），但是这是不推荐的（线程安全问题）。123456789# 以线程ID号作为key的字典 -&gt; Local -&gt; LocalStock# AppContext RequestContext -&gt; LocalStack# Flask -&gt; AppContext Request -&gt; RequestContext# current_app -&gt; (LocalStack.top = AppContext top.app = Flask 只有一个)# request -&gt; (LocalStack.top = RequestContext top.request = Request 多个)]]></content>
      <categories>
        <category>Python</category>
        <category>Flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask学习与Python进阶-2-With语句详解]]></title>
    <url>%2F2018%2F04%2F02%2FFlask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6-2-With%E8%AF%AD%E5%8F%A5%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Python中With的用法 在编写Python代码，需要链接数据库或打开文件时，我经常会使用with123with open(…): pass[移动端访问我的博客](/移动端访问我的博客.md) 它会帮助我们安全的关闭链接，但我不知道它的工作原理，下面让我们来仔细分析一下。我们先展示一段代码：123456789101112131415class MyResource: def __enter__(self): print('connect to resource') return self def __exit__(self, exc_type, exc_val, exc_tb): if exc_tb: print('process exception') else: print('no exception') print('close resource connection') return True def query(self): print('query data')with MyResource() as resource: resource.query() 上面代码执行的结果如下：1234connect to resourcequery datano exceptionclose resource connection 由执行的结果我们知道with语句的执行顺序 会首先调用类的enter方法，并将 enter返回的值赋给 as后的对象 执行with语句中的代码 执行 exit中的代码，这里相当于finally的作用 我们发现 exit函数有3个参数，我们来分析一下这几个参数的作用，我们修改部分代码如下：123with MyResource() as resource: 1 / 0 resource.query() 执行得到下面的结果：123connect to resourceprocess exceptionclose resource connection 显然这三个参数保存的是异常信息，我们可以在 exit中处理with中的异常信息。值得注意的是 exit的返回值，返回False，会继续在with外部抛出异常，返回True，不会继续在with外部抛出异常，什么都不返回相当于返回False。]]></content>
      <categories>
        <category>Python</category>
        <category>Flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask学习与Python进阶-1-基础知识]]></title>
    <url>%2F2018%2F03%2F30%2FFlask%E5%AD%A6%E4%B9%A0%E4%B8%8EPython%E8%BF%9B%E9%98%B6_1%2F</url>
    <content type="text"><![CDATA[Flask是基于Python的Web框架，我们主要通过学习Flask的基础知识来学习Python进阶知识。 使用pipenv 使用pipenv创建虚拟环境1pip install pipenv 在自己的项目目录下创建虚拟环境，这个虚拟环境和项目是绑定的1pipenv install 我执行上面的命令时报错了，好像是字符编码的问题，查询了一下，执行下面的2个命令就可以解决。12export LANG=en_US.UTF-8export LC_ALL=en_US.UTF-8 创建完虚拟环境后，我们需要的是启动虚拟环境1pipenv shell 这里虚拟环境的主要作用是区分开项目的环境，每个项目版本、使用的包可能都不一样，区分开来更加方便。安装flask1pipenv install flask 退出虚拟环境1exit 查看包的依赖关系1pipenv graph 在虚拟环境下执行下面的命令，可以找到当前虚拟环境的目录1pipenv --venv 创建一个简单的Flask项目，下面是最简单的Flask代码，就是下面简单的代码，我们就能运行起我们的Web服务。123456from flask import Flaskapp = Flask(__name__) # 实例化Flask对象@app.route('/hello') # 定义一个视图函数def hello():return "Hello, wsd" app.run() # 启动web服务器 可以调试模式，修改代码就可以自动重启服务器，同时可以显示详细的异常信息1app.run(debug=True) 在介绍另一种路由注册方式，比较而言第一种更加方便。1234 def hello():# 基于类的视图（即插视图）=\&gt; 不是重点return "Hello, wsd"app.add_url_rule('/hello', view_func=hello) 在这里有一个想问题，我们写Python代码时经常会写下面的代码：12if __name__ == '__main__': app.run(host='0.0.0.0', debug=app.config['DEBUG']()) # 启动web服务器 这里为什么要写 if name == ‘main’呢？在一般的Python代码里，原因是确保if内的语句只在当前文件作为入口文件时执行，不会在其他模块导入时执行而在Flask项目中，除了上面的原因，还因为Python Web项目的生产环境一般为nginx + uwsgi, if下面的语句是启用了一个Flask自带的服务器，在生产环境下不会启动自带的服务器，如果没有if判断生产环境下就会执行下面的语句，就会启动flask默认的服务器]]></content>
      <categories>
        <category>Python</category>
        <category>Flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动端访问我的博客]]></title>
    <url>%2F2018%2F03%2F30%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>移动端访问</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些想法]]></title>
    <url>%2F2018%2F03%2F30%2F%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写一些自己的想法 由于上了研究生，接触了很多深入的知识，也不可能仅仅停留在使用上了，在这个博客里，我会更新我的学习收获，大致的目录如下： 安全查询方面的内容和代码。 Flask框架核心与Python的使用。 英语学习的收获和感悟。 线性代数等数学知识的深入。 机器学习能知识。希望能不断完善自己的知识。]]></content>
      <categories>
        <category>想法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[timeline]]></title>
    <url>%2Ftimeline%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[关于我]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[写一些自己的想法 现在在西安读研究生，希望能总结下自己的学习内容。 可以访问我的邮箱:wwg377655460@126.comQQ:377655460希望可以多多交流。]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
